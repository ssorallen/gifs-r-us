{"version":3,"sources":["GiphyApiConstants.ts","store/actions.tsx","Gif.tsx","pages/GifPage.tsx","Navbar.tsx","pages/SearchPage.tsx","pages/TrendingPage.tsx","store/gifReducer.ts","store/searchReducer.ts","store/trendingReducer.ts","store/store.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["GIPHY_API_KEY","fetchTrending","offset","dispatch","getState","a","trending","fetch","console","log","controller","AbortController","data","type","res","json","error","response","search","q","encodeURIComponent","Gif","fluid","gif","size","gifImage","images","React","useState","imageComplete","setImageComplete","useEffect","image","Image","onload","src","url","className","style","height","width","alt","title","SLUG_REGEXP","GifPage","slug","useParams","useDispatch","useSelector","state","match","exec","id","fetchGif","stateFetch","abort","Helmet","username","import_datetime","Navbar","history","useHistory","URLSearchParams","useLocation","get","value","setValue","to","aria-label","role","action","onSubmit","event","preventDefault","push","name","onChange","e","target","placeholder","SearchPage","gifs","offsetBottom","totalCount","handleScroll","window","addEventListener","removeEventListener","document","documentElement","scrollHeight","scrollY","clientHeight","toLocaleString","map","rowSpan","Math","ceil","parseInt","fixed_width","key","gridRowEnd","TrendingPage","initialState","offsetTop","createStore","combineReducers","nextGifs","slice","pagination","forEach","index","count","total_count","applyMiddleware","thunk","App","defaultTitle","titleTemplate","store","path","Boolean","location","hostname","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.58167257.chunk.js","sourcesContent":["export const GIPHY_API_KEY = \"8XWWa7n9GFMi4XySzQYnp9esBGiGBeul\";\nexport const GIPHY_REQUEST_LIMIT = 25;\n","import {\n  Dispatch,\n  GetState,\n  GiphyApiGifResponse,\n  GiphyApiSearchResponse,\n  GiphyApiTrendingResponse,\n} from \"../types\";\nimport { GIPHY_API_KEY, GIPHY_REQUEST_LIMIT } from \"../GiphyApiConstants\";\n\nexport function cancelFetchTrending() {\n  return (dispatch: Dispatch, getState: GetState) => {\n    const { fetch: stateFetch } = getState().trending;\n    if (stateFetch != null) {\n      stateFetch.controller.abort();\n      dispatch({ type: \"fetch-trending-cancelled\" });\n    }\n  };\n}\n\nexport function fetchTrending({ offset }: { offset: number }) {\n  return async function (dispatch: Dispatch, getState: GetState) {\n    const { fetch: stateFetch } = getState().trending;\n    if (stateFetch != null) {\n      console.log(\"[trending] Fetch already pending. Ignoring fetch action.\");\n      return;\n    }\n\n    const controller = new AbortController();\n    dispatch({ data: { controller }, type: \"fetch-trending-start\" });\n\n    console.log(\n      `[trending] Fetching with offset:${offset}, limit:${GIPHY_REQUEST_LIMIT} `\n    );\n\n    let json: GiphyApiTrendingResponse;\n    try {\n      const res = await fetch(\n        `https://api.giphy.com/v1/gifs/trending?api_key=${GIPHY_API_KEY}&limit=${GIPHY_REQUEST_LIMIT}&offset=${offset}`\n      );\n      json = await res.json();\n    } catch (error) {\n      dispatch({ data: { error }, type: \"fetch-trending-error\" });\n      return;\n    }\n\n    dispatch({ data: { response: json }, type: \"fetch-trending-success\" });\n  };\n}\n\nexport function cancelSearch() {\n  return (dispatch: Dispatch, getState: GetState) => {\n    const { fetch: stateFetch } = getState().search;\n    if (stateFetch != null) {\n      stateFetch.controller.abort();\n      dispatch({ type: \"search-cancelled\" });\n    }\n  };\n}\n\nexport function search({ offset, q }: { offset: number; q: string }) {\n  return async function (dispatch: Dispatch, getState: GetState) {\n    const { fetch: stateFetch } = getState().search;\n    if (stateFetch != null) {\n      console.log(\"[search] Fetch already pending. Ignoring search action.\");\n      return;\n    }\n\n    const controller = new AbortController();\n    dispatch({ data: { controller }, type: \"search-start\" });\n\n    console.log(\n      `[search] Fetching with offset:${offset}, limit:${GIPHY_REQUEST_LIMIT} `\n    );\n\n    let json: GiphyApiSearchResponse;\n    try {\n      const res = await fetch(\n        `https://api.giphy.com/v1/gifs/search?q=${encodeURIComponent(\n          q\n        )}&api_key=${GIPHY_API_KEY}&limit=${GIPHY_REQUEST_LIMIT}&offset=${offset}`\n      );\n      json = await res.json();\n    } catch (error) {\n      dispatch({ data: { error }, type: \"search-error\" });\n      return;\n    }\n\n    dispatch({ data: { response: json }, type: \"search-success\" });\n  };\n}\n\nexport function cancelFetchGif() {\n  return (dispatch: Dispatch, getState: GetState) => {\n    const { fetch: stateFetch } = getState().gif;\n    if (stateFetch != null) {\n      stateFetch.controller.abort();\n      dispatch({ type: \"fetch-gif-cancelled\" });\n    }\n  };\n}\n\nexport function fetchGif(id: string) {\n  return async function (dispatch: Dispatch) {\n    cancelFetchGif();\n\n    const controller = new AbortController();\n    dispatch({ data: { controller }, type: \"fetch-gif-start\" });\n\n    let json: GiphyApiGifResponse;\n    try {\n      const res = await fetch(\n        `https://api.giphy.com/v1/gifs/${id}?api_key=${GIPHY_API_KEY}`\n      );\n      json = await res.json();\n    } catch (error) {\n      dispatch({ data: { error }, type: \"fetch-gif-error\" });\n      return;\n    }\n\n    dispatch({ data: { response: json }, type: \"fetch-gif-success\" });\n  };\n}\n","import \"./Gif.css\";\nimport React from \"react\";\nimport { Gif as TGif } from \"./types\";\n\ntype Props = {\n  fluid?: boolean;\n  gif: TGif;\n  size?: \"downsized\" | \"fixed_width\";\n};\n\nexport default function Gif({\n  fluid = true,\n  gif,\n  size = \"fixed_width\",\n}: Props) {\n  const gifImage = gif.images[size];\n  const [imageComplete, setImageComplete] = React.useState(false);\n\n  React.useEffect(() => {\n    // Once the image has finished loading, render the actual `<img>` tag and unset `onload` so the\n    // Image object has no other reference in memory and can be garbage collected.\n    const image = new Image();\n    image.onload = () => {\n      setImageComplete(true);\n      image.onload = null;\n    };\n    image.src = gifImage.url;\n\n    // If the Gif is removed before loading is complete:\n    // * ensure no onload runs\n    // * set the `src` to empty string to cancel inflight requests\n    return () => {\n      image.onload = null;\n      image.src = \"\";\n    };\n  }, [gifImage.url]);\n\n  return (\n    <div\n      className={`gif ${imageComplete ? \"\" : \"gif-loading\"}`}\n      // Ensure container always has dimensions even when the <img> is not yet rendered.\n      style={\n        fluid\n          ? {}\n          : {\n              height: `${gifImage.height}px`,\n              width: `${gifImage.width}px`,\n            }\n      }\n    >\n      {imageComplete ? (\n        <img\n          alt=\"\"\n          className=\"img-fluid\"\n          height={gifImage.height}\n          src={gifImage.url}\n          title={gif.title}\n          width={gifImage.width}\n        />\n      ) : null}\n    </div>\n  );\n}\n","import { cancelFetchGif, fetchGif } from \"../store/actions\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { AppState } from \"../types\";\nimport Gif from \"../Gif\";\nimport { Helmet } from \"react-helmet\";\nimport React from \"react\";\nimport { useParams } from \"react-router-dom\";\n\nconst SLUG_REGEXP = /([^-]+)$/;\n\nexport default function GifPage() {\n  const { slug } = useParams();\n  const dispatch = useDispatch();\n  const gif = useSelector((state: AppState) => state.gif.gif);\n  const match = SLUG_REGEXP.exec(slug);\n  const id = match == null ? \"\" : match[0];\n\n  React.useEffect(() => {\n    dispatch(fetchGif(id));\n    return () => {\n      dispatch(cancelFetchGif());\n    };\n  }, [dispatch, id]);\n\n  return (\n    <div className=\"py-3\">\n      {gif == null ? null : (\n        <>\n          <Helmet title={gif.title === \"\" ? gif.id : gif.title} />\n          {gif.title === \"\" ? null : <h3>{gif.title}</h3>}\n          <p>\n            {gif.username === \"\" ? null : <>@{gif.username} &middot; </>}\n            {gif.import_datetime}\n          </p>\n          <Gif gif={gif} size=\"downsized\" />\n        </>\n      )}\n    </div>\n  );\n}\n","import { Link, useHistory } from \"react-router-dom\";\nimport React from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\nexport default function Navbar() {\n  const history = useHistory();\n  const loc = new URLSearchParams(useLocation().search);\n  const q = loc.get(\"q\");\n  const [value, setValue] = React.useState(q);\n\n  // Sync the local state when the `q` search param changes but let the form submission handle\n  // persisting the new value to the URL.\n  React.useEffect(() => {\n    setValue(q);\n  }, [q]);\n\n  function handleSubmit(event: React.FormEvent<HTMLFormElement>) {\n    event.preventDefault();\n    history.push(`/search?q=${value}`);\n  }\n\n  return (\n    <nav className=\"navbar\">\n      <Link className=\"navbar-brand\" to=\"/\">\n        Gifs-R-Us{\" \"}\n        <span aria-label=\"\" role=\"img\">\n          🎉\n        </span>\n      </Link>\n      <form action=\"/search\" className=\"form-inline\" onSubmit={handleSubmit}>\n        <div className=\"input-group\">\n          <input\n            aria-label=\"Search all the GIFs\"\n            className=\"form-control\"\n            name=\"q\"\n            onChange={(e) => {\n              setValue(e.target.value);\n            }}\n            placeholder=\"Search all the GIFs\"\n            type=\"search\"\n            value={value == null ? \"\" : value}\n          />\n          <div className=\"input-group-append\">\n            <button className=\"btn btn-outline-success\" type=\"submit\">\n              <span aria-label=\"Search\" role=\"img\">\n                🔎\n              </span>\n            </button>\n          </div>\n        </div>\n      </form>\n    </nav>\n  );\n}\n","import { useDispatch, useSelector } from \"react-redux\";\nimport { AppState } from \"../types\";\nimport Gif from \"../Gif\";\nimport { Helmet } from \"react-helmet\";\nimport { Link } from \"react-router-dom\";\nimport React from \"react\";\nimport { cancelSearch, search } from \"../store/actions\";\nimport { useLocation } from \"react-router-dom\";\n\n// Must match .grid{row-gap, grid-row-height} in Trending.css. Extract to a values sharable in JS?\nconst GRID_GAP_PX = 10;\nconst GRID_ROW_HEIGHT_PX = 10;\n\n// If the scroll offset reaches anywhere from the bottom up to this many pixels away, fire off\n// another request for trending.\nconst SCROLL_BOTTOM_THRESHOLD_PX = 50;\n\nexport default function SearchPage() {\n  const q = new URLSearchParams(useLocation().search).get(\"q\");\n  const dispatch = useDispatch();\n  const gifs = useSelector((state: AppState) => state.search.gifs);\n  const offsetBottom = useSelector(\n    (state: AppState) => state.search.offsetBottom\n  );\n  const totalCount = useSelector((state: AppState) => state.search.totalCount);\n\n  React.useEffect(() => {\n    // No query? Nothing to search for.\n    if (q == null) return;\n\n    dispatch(search({ offset: 0, q }));\n    return () => {\n      dispatch(cancelSearch());\n    };\n  }, [dispatch, q]);\n\n  React.useEffect(() => {\n    // No query? Nothing to search for.\n    if (q == null) return;\n\n    function handleScroll() {\n      if (\n        document.documentElement.scrollHeight -\n          (window.scrollY + document.documentElement.clientHeight) <=\n        SCROLL_BOTTOM_THRESHOLD_PX\n      ) {\n        // Should the `q == null` check above not narrow the type to `string`?\n        // @ts-ignore\n        dispatch(search({ offset: offsetBottom, q }));\n      }\n    }\n\n    // Check the first time whether more GIFs are needed. This ensures screens that are taller than\n    // initial set of GIFs will load more. This works to fill the screen because as `offsetBottom`\n    // changes this `useEffect` will get called again.\n    handleScroll();\n\n    window.addEventListener(\"scroll\", handleScroll);\n    return () => {\n      window.removeEventListener(\"scroll\", handleScroll);\n    };\n  }, [dispatch, offsetBottom, q]);\n\n  return (\n    <>\n      <Helmet title={`${q} GIFs`} />\n      <div className=\"py-3\">\n        <h3>\n          {q}{\" \"}\n          <small className=\"text-muted\">\n            {totalCount.toLocaleString()} GIFs\n          </small>\n        </h3>\n        <div className=\"grid\">\n          {gifs.map((gif) => {\n            const rowSpan = Math.ceil(\n              (parseInt(gif.images.fixed_width.height, 10) + GRID_GAP_PX) /\n                (GRID_ROW_HEIGHT_PX + GRID_GAP_PX)\n            );\n            return (\n              <Link\n                key={gif.id}\n                style={{ gridRowEnd: `span ${rowSpan}` }}\n                to={`/gifs/${gif.id}`}\n              >\n                <Gif fluid={false} gif={gif} />\n              </Link>\n            );\n          })}\n        </div>\n      </div>\n    </>\n  );\n}\n","import { useDispatch, useSelector } from \"react-redux\";\nimport { AppState } from \"../types\";\nimport Gif from \"../Gif\";\nimport { Helmet } from \"react-helmet\";\nimport { Link } from \"react-router-dom\";\nimport React from \"react\";\nimport { cancelFetchTrending, fetchTrending } from \"../store/actions\";\n\n// Must match .grid{row-gap, grid-row-height} in Trending.css. Extract to a values sharable in JS?\nconst GRID_GAP_PX = 10;\nconst GRID_ROW_HEIGHT_PX = 10;\n\n// If the scroll offset reaches anywhere from the bottom up to this many pixels away, fire off\n// another request for trending.\nconst SCROLL_BOTTOM_THRESHOLD_PX = 50;\n\nexport default function TrendingPage() {\n  const dispatch = useDispatch();\n  const gifs = useSelector((state: AppState) => state.trending.gifs);\n  const offsetBottom = useSelector(\n    (state: AppState) => state.trending.offsetBottom\n  );\n\n  React.useEffect(() => {\n    dispatch(fetchTrending({ offset: 0 }));\n    return () => {\n      dispatch(cancelFetchTrending());\n    };\n  }, [dispatch]);\n\n  React.useEffect(() => {\n    function handleScroll() {\n      if (\n        document.documentElement.scrollHeight -\n          (window.scrollY + document.documentElement.clientHeight) <=\n        SCROLL_BOTTOM_THRESHOLD_PX\n      ) {\n        dispatch(fetchTrending({ offset: offsetBottom }));\n      }\n    }\n\n    // Check the first time whether more GIFs are needed. This ensures screens that are taller than\n    // initial set of GIFs will load more. This works to fill the screen because as `offsetBottom`\n    // changes this `useEffect` will get called again.\n    handleScroll();\n\n    window.addEventListener(\"scroll\", handleScroll);\n    return () => {\n      window.removeEventListener(\"scroll\", handleScroll);\n    };\n  }, [dispatch, offsetBottom]);\n\n  return (\n    <>\n      <Helmet title=\"Trending GIFs\" />\n      <div className=\"py-3\">\n        <h3>Trending</h3>\n        <div className=\"grid\">\n          {gifs.map((gif) => {\n            const rowSpan = Math.ceil(\n              (parseInt(gif.images.fixed_width.height, 10) + GRID_GAP_PX) /\n                (GRID_ROW_HEIGHT_PX + GRID_GAP_PX)\n            );\n            return (\n              <Link\n                key={gif.id}\n                style={{ gridRowEnd: `span ${rowSpan}` }}\n                to={`/gifs/${gif.slug}`}\n              >\n                <Gif fluid={false} gif={gif} />\n              </Link>\n            );\n          })}\n        </div>\n      </div>\n    </>\n  );\n}\n","import { Action, GifState } from \"../types\";\n\nconst initialState: GifState = {\n  fetch: null,\n  gif: null,\n};\n\nexport default function gifReducer(state = initialState, action: Action) {\n  switch (action.type) {\n    case \"fetch-gif-cancelled\":\n      return {\n        ...state,\n        fetch: null,\n      };\n    case \"fetch-gif-error\":\n      return {\n        ...state,\n        fetch: null,\n      };\n    case \"fetch-gif-start\":\n      return {\n        ...state,\n        gif: null,\n        fetch: {\n          ...action.data,\n        },\n      };\n    case \"fetch-gif-success\":\n      return {\n        ...state,\n        fetch: null,\n        gif: action.data.response.data,\n      };\n    default:\n      return state;\n  }\n}\n","import { Action, SearchState } from \"../types\";\n\nconst initialState: SearchState = {\n  fetch: null,\n  gifs: [],\n  offsetBottom: 0,\n  offsetTop: 0,\n  totalCount: 0,\n};\n\nexport default function SearchReducer(state = initialState, action: Action) {\n  switch (action.type) {\n    case \"search-cancelled\":\n      return {\n        ...state,\n        fetch: null,\n      };\n    case \"search-error\":\n      return {\n        ...state,\n        fetch: null,\n      };\n    case \"search-start\":\n      return {\n        ...state,\n        fetch: {\n          ...action.data,\n        },\n      };\n    case \"search-success\": {\n      // Use the `gifs` array as a sparse array so the offset can match the offset on the server\n      // without taking up actual memory in the client.\n      const nextGifs = state.gifs.slice();\n      const offset = action.data.response.pagination.offset;\n      action.data.response.data.forEach((gif, index) => {\n        nextGifs[offset + index] = gif;\n      });\n\n      return {\n        ...state,\n        fetch: null,\n        gifs: nextGifs,\n        offsetBottom:\n          state.offsetBottom + action.data.response.pagination.count,\n        totalCount: action.data.response.pagination.total_count,\n      };\n    }\n    default:\n      return state;\n  }\n}\n","import { Action, TrendingState } from \"../types\";\n\nconst initialState: TrendingState = {\n  fetch: null,\n  gifs: [],\n  offsetBottom: 0,\n  offsetTop: 0,\n};\n\nexport default function trendingReducer(state = initialState, action: Action) {\n  switch (action.type) {\n    case \"fetch-trending-cancelled\":\n      return {\n        ...state,\n        fetch: null,\n      };\n    case \"fetch-trending-error\":\n      return {\n        ...state,\n        fetch: null,\n      };\n    case \"fetch-trending-start\":\n      return {\n        ...state,\n        fetch: {\n          ...action.data,\n        },\n      };\n    case \"fetch-trending-success\": {\n      // Use the `gifs` array as a sparse array so the offset can match the offset on the server\n      // without taking up actual memory in the client.\n      const nextGifs = state.gifs.slice();\n      const offset = action.data.response.pagination.offset;\n      action.data.response.data.forEach((gif, index) => {\n        nextGifs[offset + index] = gif;\n      });\n\n      return {\n        ...state,\n        fetch: null,\n        gifs: nextGifs,\n        offsetBottom:\n          state.offsetBottom + action.data.response.pagination.count,\n      };\n    }\n    default:\n      return state;\n  }\n}\n","import { combineReducers, createStore, applyMiddleware } from \"redux\";\nimport gifReducer from \"./gifReducer\";\nimport searchReducer from \"./searchReducer\";\nimport thunk from \"redux-thunk\";\nimport trendingReducer from \"./trendingReducer\";\n\nexport default createStore(\n  combineReducers({\n    gif: gifReducer,\n    search: searchReducer,\n    trending: trendingReducer,\n  }),\n  applyMiddleware(thunk)\n);\n","import \"bootstrap/dist/css/bootstrap.min.css\";\nimport \"./App.css\";\nimport { HashRouter as Router, Route, Switch } from \"react-router-dom\";\nimport GifPage from \"./pages/GifPage\";\nimport { Helmet } from \"react-helmet\";\nimport Navbar from \"./Navbar\";\nimport SearchPage from \"./pages/SearchPage\";\nimport TrendingPage from \"./pages/TrendingPage\";\nimport { Provider } from \"react-redux\";\nimport React from \"react\";\nimport store from \"./store/store\";\n\nexport default function App() {\n  return (\n    <>\n      <Helmet defaultTitle=\"Gifs-R-Us\" titleTemplate=\"%s &middot; Gifs-R-Us\" />\n      <Provider store={store}>\n        <Router>\n          <Navbar />\n          <div className=\"container\">\n            <Switch>\n              <Route path=\"/gifs/:slug\">\n                <GifPage />\n              </Route>\n              <Route path=\"/search\">\n                <SearchPage />\n              </Route>\n              <Route path=\"/\">\n                <TrendingPage />\n              </Route>\n            </Switch>\n          </div>\n        </Router>\n      </Provider>\n    </>\n  );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}